package com.nuvolect.pentest.survey;//

import android.accounts.Account;
import android.accounts.AccountManager;
import android.content.Context;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.os.Environment;
import android.os.StatFs;
import android.provider.Settings;

import com.nuvolect.pentest.util.PermissionUtil;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.security.NoSuchAlgorithmException;
import java.util.List;
import java.util.Locale;

import javax.net.ssl.SSLContext;

/**
 * Query details about a device.
 */
public class DeviceInfo {

    /**
     * Return a unique string for the device.  This string only changes when you wipe the device
     * and reinstall Android.
     * @param context
     * @return unique device ID string
     */
    public static String getUniqueInstallId(Context context) {

        String deviceId = Settings.Secure.getString( context.getContentResolver(), Settings.Secure.ANDROID_ID);
        return deviceId;
    }
    /**
     * Retrieves phone make and model
     * @return
     */
    public static String getMakeModelName() {
        String manufacturer = android.os.Build.MANUFACTURER;
        String model = android.os.Build.MODEL;

        if (model.startsWith(manufacturer)) {
            return capitalize(model);
        } else {
            return capitalize(manufacturer) + " " + model;
        }
    }
    //Used for the phone model
    private static String capitalize(String s) {

        if (s == null || s.length() == 0) {
            return "";
        }
        char first = s.charAt(0);
        if (Character.isUpperCase(first)) {
            return s;
        } else {
            return Character.toUpperCase(first) + s.substring(1);
        }
    }

    /**
     * Return a JSON object with device information
     * manufacturer
     * model
     * uniqueInstalledId
     * ssl
     * accounts
     * wifiList
     * logCat
     *
     * @param ctx
     * @return
     */
    public static JSONObject getInfo(Context ctx) {

        JSONObject object = new JSONObject();

        try {
            object.put("manufacturer", android.os.Build.MANUFACTURER);
            object.put("model", android.os.Build.MODEL);
            object.put("uniqueInstallId", getUniqueInstallId( ctx ));
            object.put("ssl", getSslDetails());
            object.put("accounts", getAccounts( ctx ));
            object.put("wifiList", getWifiConfigured( ctx ));
            object.put("externalStorageAvailable", externalMemoryAvailable());
            object.put("internalMemorySize", getInternalMemorySize());
            object.put("externalStorageSize", getTotalExternalStorageSize());
            object.put("deviceInfo", com.nuvolect.pentest.util.DeviceInfo.getDeviceInfo(ctx));

        } catch (JSONException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }

        return object;
    }

    private static JSONArray getWifiConfigured(Context ctx) {
        
        JSONArray wifiList = new JSONArray();
        WifiManager wifiManager = (WifiManager) ctx.getSystemService(Context.WIFI_SERVICE);
        List<WifiConfiguration> wifiConfiguredList = wifiManager.getConfiguredNetworks();

        for( WifiConfiguration wifi : wifiConfiguredList){

            wifiList.put( wifi.SSID);
        }
        return wifiList;
    }

    private static String getSslDetails() throws NoSuchAlgorithmException {
        
        SSLContext sslContext = SSLContext.getInstance("TLS");
        String details = sslContext.getProtocol();
        details += ", "+ sslContext.getProvider().toString();
        
        return details;
    }

    private static JSONArray getAccounts(Context ctx) {

        JSONArray accounts = new JSONArray();
        
        if( PermissionUtil.canGetAccounts( ctx )){

            Account[] myAccounts = AccountManager.get( ctx ).getAccounts();

            for (Account myAccount : myAccounts) {

                String account = myAccount.name.toLowerCase(Locale.US).trim();
                accounts.put( account);
            }
        }
        return accounts;
    }

    public static JSONArray getLogCat(){

        JSONArray log = new JSONArray();
        try {
            Process process = Runtime.getRuntime().exec("logcat -d");
            BufferedReader bufferedReader = new BufferedReader(
                    new InputStreamReader(process.getInputStream()));

            String line = "";
            while ((line = bufferedReader.readLine()) != null) {
                log.put(line);
            }
        }
        catch (IOException e) {}

        return log;
    }

    public static JSONArray getShell(String shell_cmd) {

        JSONArray log = new JSONArray();
        try {
            Process process = Runtime.getRuntime().exec( shell_cmd );
            BufferedReader bufferedReader = new BufferedReader(
                    new InputStreamReader(process.getInputStream()));

            String line = "";
            while ((line = bufferedReader.readLine()) != null) {
                log.put(line);
            }
        }
        catch (IOException e) {
            log.put("exception");
        }

        return log;
    }

    public static boolean externalMemoryAvailable() {

        return android.os.Environment.getExternalStorageState().equals(
                android.os.Environment.MEDIA_MOUNTED);
    }

    public static String getInternalMemorySize() {

        File path = Environment.getDataDirectory();
        StatFs stat = new StatFs(path.getPath());
        long blockSize = stat.getBlockSize();
        long availableBlocks = stat.getAvailableBlocks();
        return formatSize(availableBlocks * blockSize);
    }

    public static String getTotalExternalStorageSize() {

        String ERROR = "Information request error";

        if (externalMemoryAvailable()) {
            File path = Environment.getExternalStorageDirectory();
            StatFs stat = new StatFs(path.getPath());
            long blockSize = stat.getBlockSize();
            long totalBlocks = stat.getBlockCount();
            return formatSize(totalBlocks * blockSize);
        } else {
            return ERROR;
        }
    }

    public static String formatSize(long size) {

        String suffix = null;

        if (size >= 1024) {
            suffix = "KB";
            size /= 1024;
            if (size >= 1024) {
                suffix = "MB";
                size /= 1024;
            }
        }

        StringBuilder resultBuffer = new StringBuilder(Long.toString(size));

        int commaOffset = resultBuffer.length() - 3;
        while (commaOffset > 0) {
            resultBuffer.insert(commaOffset, ',');
            commaOffset -= 3;
        }

        if (suffix != null) resultBuffer.append(suffix);
        return resultBuffer.toString();
    }
}
