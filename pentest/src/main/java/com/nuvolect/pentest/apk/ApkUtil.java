package com.nuvolect.pentest.apk;

import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.widget.Toast;

import com.googlecode.dex2jar.Method;
import com.googlecode.dex2jar.ir.IrMethod;
import com.googlecode.dex2jar.reader.DexFileReader;
import com.googlecode.dex2jar.v3.Dex2jar;
import com.googlecode.dex2jar.v3.DexExceptionHandler;
import com.nuvolect.pentest.util.LogUtil;
import com.nuvolect.pentest.util.OmniFile;
import com.nuvolect.pentest.util.OmniHash;
import com.nuvolect.pentest.util.OmniZip;
import com.nuvolect.pentest.util.Util;
import com.nuvolect.pentest.webserver.connector.VolUtil;

import net.dongliu.apk.parser.ApkParser;
import net.dongliu.apk.parser.bean.DexClass;

import org.apache.commons.io.FilenameUtils;
import org.benf.cfr.reader.state.ClassFileSourceImpl;
import org.benf.cfr.reader.state.DCCommonState;
import org.benf.cfr.reader.util.getopt.GetOptParser;
import org.benf.cfr.reader.util.getopt.OptionsImpl;
import org.benf.cfr.reader.util.output.DumperFactoryImpl;
import org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler;
import org.jetbrains.java.decompiler.main.decompiler.PrintStreamLogger;
import org.jf.dexlib2.DexFileFactory;
import org.jf.dexlib2.iface.ClassDef;
import org.jf.dexlib2.immutable.ImmutableDexFile;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.objectweb.asm.tree.MethodNode;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import jadx.api.JadxDecompiler;
import jadx.core.utils.exceptions.JadxException;

import static com.nuvolect.pentest.util.OmniZip.unzipFile;

/**
 * Utilities to work with APK files.
 * A top level folder is created at CConst.APP_FOLDER_NAME
 * Sub-folders are created for each app named with the package name
 * Sub-folders contain
 * 1. the APK file,
 * 2. the unpacked APK file and
 * 3. decompiled class files in subfolders src{cfr, jadx, fern}
 *
 * _status is for 0/1 apk and dex file exists status
 * _thread status has states {running, stopped, null}
 * running: compile process is running
 * stopped: comple process has stopped, folder exists
 * null: compile process is not running, folder does not exist
 */
public class ApkUtil {

    private static String m_topFolderUrl = "";
    private static String m_topFolderFullPath;
    private static String m_appFolderFullPath;
    private static String m_appFolderRelativePath;
    private static OmniFile m_appFolder;
    private static String m_appFolderUrl;
    private static String m_appApkFullPath;
    private static OmniFile m_dexFile;
    private static String m_dexFullPath;
    private static String m_jarFullPath;
    private static OmniFile m_jarFile;
    private static String m_srcCfrFolderPath;
    private static OmniFile m_srcCfrFolder;
    private static String m_srcJadxFolderPath;
    private static OmniFile m_srcJadxFolder;
    private static String m_srcFernFolderPath;
    private static OmniFile m_srcFernFolder;
    private static ProgressStream m_progressStream;

    //    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
    //    STACK_SIZE = Integer.valueOf(prefs.getString("thread_stack_size", String.valueOf(20 * 1024 * 1024)));
    //    IGNORE_LIBS = prefs.getBoolean("ignore_libraries", true);
    private static int STACK_SIZE = 20 * 1024 * 1024;

    private static Thread m_unpackApkThread = null;
    private static Thread m_dex2jarThread = null;
    private static Thread m_cfrThread = null;
    private static Thread m_jadxThread = null;
    private static Thread m_fernThread = null;
    private static String UNZIP_APK_THREAD = "Unpack APK java thread";
    private static String DEX2JAR_THREAD = "DEX to JAR java thread";
    private static String CFL_THREAD = "CFL jar to java thread";
    private static String JADX_THREAD = "JaDX jar to java thread";
    private static String FERN_THREAD = "FernFlower jar to java thread";
    private static DexClass[] m_dexClasses;
    private static List<String> ignoredLibs = new ArrayList();

    public enum MY_THREAD { unpack_apk, dex2jar, cfr, jadx, fern_flower, simple_unpack};

    /**
     * Create a working folder for the app then create a sub-folder based on the package name.
     * @param ctx
     * @return
     */
    public static JSONObject init(Context ctx, String package_name) {

        m_progressStream = new ProgressStream();

        m_topFolderFullPath = Util.createAppPublicFolder();
        if (m_topFolderFullPath.isEmpty()) {
            Toast.makeText(ctx, "SDCARD folder creation error", Toast.LENGTH_LONG).show();
        } else {
            m_topFolderUrl = OmniHash.getHashedServerUrlFullPath(ctx,
                    VolUtil.sdcardVolumeId, m_topFolderFullPath);

            m_appFolderFullPath = m_topFolderFullPath + "/" + package_name;
            String rootPath = VolUtil.getRoot(VolUtil.sdcardVolumeId);
            m_appFolderRelativePath = m_appFolderFullPath.replace(rootPath, "/");
            m_appFolder = new OmniFile(VolUtil.sdcardVolumeId, m_appFolderFullPath);
            if (!m_appFolder.exists()) {
                m_appFolder.mkdir();
            }
            m_appFolderUrl = OmniHash.getHashedServerUrlFullPath(ctx,
                    VolUtil.sdcardVolumeId, m_appFolderFullPath);

        }
        return getStatus(ctx, package_name);
    }

    /**
     * Update member variables paths, and files. Return thread status and URLs.
     * @param ctx
     * @param package_name
     * @return
     */
    public static JSONObject getStatus(Context ctx, String package_name) {

        boolean apkFileExists = false;
        boolean dexFileExists = false;
        boolean dex2jarFileExists = false;
        boolean cfrFolderExists = false;
        boolean jadxFolderExists = false;
        boolean fernFolderExists = false;
        JSONObject wrapper = new JSONObject();

        /**
         * Update status on tasks performed
         */
        m_appApkFullPath = m_appFolderFullPath+"/"+package_name+".apk";
        OmniFile apkFile = new OmniFile(VolUtil.sdcardVolumeId, m_appApkFullPath);
        apkFileExists = apkFile.exists();

        m_dexFullPath = m_appFolderFullPath+"/classes.dex";
        m_dexFile = new OmniFile(VolUtil.sdcardVolumeId, m_dexFullPath);
        dexFileExists = m_dexFile.exists();

        m_jarFullPath = m_appFolderFullPath+"/"+package_name+".jar";
        m_jarFile = new OmniFile(VolUtil.sdcardVolumeId, m_jarFullPath);
        dex2jarFileExists = m_jarFile.exists();

        m_srcCfrFolderPath = m_appFolderFullPath+"/srcCfr";
        m_srcCfrFolder = new OmniFile(VolUtil.sdcardVolumeId, m_srcCfrFolderPath);
        cfrFolderExists = m_srcCfrFolder.exists();

        m_srcJadxFolderPath = m_appFolderFullPath+"/srcJadx";
        m_srcJadxFolder = new OmniFile(VolUtil.sdcardVolumeId, m_srcJadxFolderPath);
        jadxFolderExists = m_srcJadxFolder.exists();

        m_srcFernFolderPath = m_appFolderFullPath+"/srcFern";
        m_srcFernFolder = new OmniFile(VolUtil.sdcardVolumeId, m_srcFernFolderPath);
        fernFolderExists = m_srcFernFolder.exists();

        try {

            wrapper.put("copy_apk_status", apkFileExists ?1:0);
            wrapper.put("copy_apk_url", m_appFolderUrl);
            wrapper.put("unpack_apk_url", m_appFolderUrl);
            wrapper.put("dex2jar_url", m_appFolderUrl);
            wrapper.put("app_folder_path", m_appFolderRelativePath);

            if(cfrFolderExists){
                String url = OmniHash.getHashedServerUrlFullPath(ctx,
                        VolUtil.sdcardVolumeId, m_srcCfrFolderPath);
                wrapper.put("cfr_url", url);
            }
            else
                wrapper.put("cfr_url", m_appFolderUrl);

            if(jadxFolderExists){
                String url = OmniHash.getHashedServerUrlFullPath(ctx,
                        VolUtil.sdcardVolumeId, m_srcJadxFolderPath);
                wrapper.put("jadx_url", url);
            }
            else
                wrapper.put("jadx_url", m_appFolderUrl);

            if(fernFolderExists){
                String url = OmniHash.getHashedServerUrlFullPath(ctx,
                        VolUtil.sdcardVolumeId, m_srcFernFolderPath);
                wrapper.put("fern_url", url);
            }
            else
                wrapper.put("fern_url", m_appFolderUrl);

            wrapper.put("unpack_apk_thread", getThreadStatus( dexFileExists, m_unpackApkThread));
            wrapper.put("dex2jar_thread",    getThreadStatus( dex2jarFileExists, m_dex2jarThread));
            wrapper.put("cfr_thread",        getThreadStatus( cfrFolderExists, m_cfrThread));
            wrapper.put("jadx_thread",       getThreadStatus( jadxFolderExists, m_jadxThread));
            wrapper.put("fern_thread",       getThreadStatus( fernFolderExists, m_fernThread));

        } catch (JSONException e) {
            e.printStackTrace();
        }

        return wrapper;
    }

    /**
     * Return the status of a compile process. The status can be one of three states:
     * running: compile process is running
     * stopped: comple process has stopped, folder exists
     * null: compile process is not running, folder does not exist
     *
     * @param folderExists
     * @param aThread
     * @return
     */
    private static String getThreadStatus(boolean folderExists, Thread aThread) {

        if( aThread != null && aThread.isAlive())
            return "running";

        if( folderExists)
            return "stopped";

        return "null";
    }


    /**
     * Copy the specific APK to working folder.
     * Return a link to the parent folder.
     * @param ctx
     * @return
     */
    public static JSONObject copyApk(Context ctx, String package_name) {

        JSONObject wrapper = new JSONObject();

        try {
            wrapper.put("copy_apk_status", 0);// 0==Start with failed file copy
            m_progressStream.putStream("Copy APK starting");

            PackageManager pm = ctx.getPackageManager();
            ApplicationInfo applicationInfo = pm.getApplicationInfo( package_name, PackageManager.GET_META_DATA);

            java.io.File inputFile = new File( applicationInfo.publicSourceDir);
            InputStream inputStream = new FileInputStream( inputFile );

            if( m_appFolderFullPath == null)
                init( ctx, package_name);

            File outputFile = new File(m_appApkFullPath);
            OutputStream outputStream = new FileOutputStream( outputFile );
            Util.copyFile( inputStream, outputStream);

            m_progressStream.putStream("Copy APK complete");

            wrapper.put("copy_apk_status", 1); // Change to success if we get here
            wrapper.put("copy_apk_url", m_appFolderUrl);

        } catch (PackageManager.NameNotFoundException | JSONException | IOException e) {
            LogUtil.logException(LogUtil.LogType.APK_UTIL, e);
            m_progressStream.putStream(e.toString());
            m_progressStream.putStream("Copy APK failed");
        }

        return wrapper;
    }

    public static JSONObject unpackApk(Context ctx, final String package_name) {

        if( m_appFolderFullPath == null)
            init( ctx, package_name);

        final Thread.UncaughtExceptionHandler uncaughtExceptionHandler = new Thread.UncaughtExceptionHandler() {
            @Override
            public void uncaughtException(Thread t, Throwable e) {

                LogUtil.log(LogUtil.LogType.APK_UTIL, "Uncaught exception: "+e.toString());
                m_progressStream.putStream("Uncaught exception: "+t.getName());
                m_progressStream.putStream("Uncaught exception: "+e.toString());
            }
        };

        ThreadGroup group = new ThreadGroup(CFL_THREAD);
        m_unpackApkThread = new Thread(group, new Runnable() {
            @Override
            public void run() {
                boolean success = false;
                try {

                    m_progressStream.putStream("Unpack APK starting");
                    OmniFile appZip = new OmniFile(VolUtil.sdcardVolumeId, m_appApkFullPath);
                    if( appZip.exists() && appZip.isFile()){

                        // Extract all files except for XML, to be extracted later
                        success = ApkZipUtil.unzipAllExceptXML(appZip, m_appFolder, m_progressStream);

                        ApkParser apkParser = new ApkParser( appZip.getStdFile());

                        // Get a list of all files in the APK and iterate and extract by type
                        List<String> paths = OmniZip.getFilesList( appZip);
                        for( String path : paths){

                            File file = new File( m_appFolderFullPath+"/"+path);
                            File parent = file.getParentFile();
                            parent.mkdirs();
                            String extension = FilenameUtils.getExtension( path);

                            if( extension.contentEquals("xml")){

                                String xml = apkParser.transBinaryXml(path);
                                Util.writeFile( file, xml);
                                m_progressStream.putStream( path);
                            }
                        }
                        // Write over manifest with unencoded version
                        String manifestXml = apkParser.getManifestXml();
                        File manifestFile = new File( m_appFolderFullPath+"/AndroidManifest.xml");
                        Util.writeFile(manifestFile, manifestXml);
                        m_progressStream.putStream("AndroidManifest.xml");

                        // APK to optimized DEX
                        org.jf.dexlib2.iface.DexFile dexFile = null;
                        try {
                            dexFile = DexFileFactory.loadDexFile(m_appApkFullPath, 19);
                        } catch( Exception e) {
                            m_progressStream.putStream("The app DEX file cannot be decompiled.");
                        }
                        List<ClassDef> classes = new ArrayList<>();
                        m_progressStream.putStream("Optimizing classes...");

                        Set<? extends ClassDef> dexClasses = dexFile.getClasses();

                        for( org.jf.dexlib2.iface.ClassDef classDef : dexFile.getClasses()){
                            if( ! isIgnored( classDef.getType())){
                                final String currentClass = classDef.getType();
                                m_progressStream.putStream("Optimising_class: "+currentClass);
                                currentClass.replaceAll("Processing ", "");
                                classes.add(classDef);
                            }
                        }

                        m_progressStream.putStream("Merging classes");
                        dexFile = new ImmutableDexFile( classes);

                        try {
                            m_progressStream.putStream("Writing optimized_classes.dex");
                            DexFileFactory.writeDexFile(m_appFolderFullPath+"/optimized_classes.dex", dexFile);
                        } catch( Exception e) {
                            m_progressStream.putStream("The app DEX file cannot be decompiled.");
                        }
                    }

                } catch (Exception | StackOverflowError e) {
                    m_progressStream.putStream(e.toString());
                }
                if( success)
                    m_progressStream.putStream("Unpack APK complete");
                else
                    m_progressStream.putStream("Unpack APK failed");
            }
        }, UNZIP_APK_THREAD, STACK_SIZE);

        m_unpackApkThread.setPriority(Thread.MAX_PRIORITY);
        m_unpackApkThread.setUncaughtExceptionHandler(uncaughtExceptionHandler);
        m_unpackApkThread.start();

        final JSONObject wrapper = new JSONObject();
        try {
            wrapper.put("unpack_apk_thread", getThreadStatus( true, m_unpackApkThread));
            wrapper.put("unpack_apk_url", m_appFolderUrl);

        } catch (JSONException e) {
            LogUtil.logException(LogUtil.LogType.APK_UTIL, e);
        }

        return wrapper;
    }
    private static boolean isIgnored(String className) {
        for (String ignoredClass : ignoredLibs) {
            if (className.startsWith(ignoredClass)) {
                return true;
            }
        }
        return false;
    }

    public static JSONObject dex2jar(Context ctx, final String package_name) {

        // DEX 2 JAR CONFIGS
        final boolean reuseReg = false; // reuse register while generate java .class file
        final boolean topologicalSort1 = false; // same with --topological-sort/-ts
        final boolean topologicalSort = false; // sort block by topological, that will generate more readable code
        final boolean verbose = true; // show progress
        final boolean debugInfo = false; // translate debug info
        final boolean printIR = false; // print ir to System.out
        final boolean optimizeSynchronized = true; // Optimise-synchronised

        if( m_appFolderFullPath == null)
            init( ctx, package_name);

        final Thread.UncaughtExceptionHandler uncaughtExceptionHandler = new Thread.UncaughtExceptionHandler() {
            @Override
            public void uncaughtException(Thread t, Throwable e) {

                LogUtil.log(LogUtil.LogType.APK_UTIL, "Uncaught exception: "+e.toString());
                m_progressStream.putStream("Uncaught exception: "+t.getName());
                m_progressStream.putStream("Uncaught exception: "+e.toString());
            }
        };

        final File jarFile = new File(m_appFolderFullPath + "/" + package_name + ".jar");
        final File dexFile = new File(m_dexFullPath);

        ThreadGroup group = new ThreadGroup(CFL_THREAD);
        m_dex2jarThread = new Thread(group, new Runnable() {
            @Override
            public void run() {
                boolean success = false;
                try {
                    m_progressStream.putStream("DEX to JAR starting");

                    if (m_dexFile.exists() && dexFile.isFile()) {

                        DexExceptionHandlerMod dexExceptionHandlerMod = new DexExceptionHandlerMod();

                        DexFileReader reader = new DexFileReader(dexFile);
                        Dex2jar dex2jar = Dex2jar
                                .from(reader)
                                .reUseReg(reuseReg)
                                .topoLogicalSort(topologicalSort || topologicalSort1)
                                .skipDebug(!debugInfo)
                                .optimizeSynchronized(optimizeSynchronized)
                                .printIR(printIR)
                                .verbose(verbose);
                        dex2jar.setExceptionHandler(dexExceptionHandlerMod);
                        dex2jar.to(jarFile);
                        success = true;
                    }
                    else
                        m_progressStream.putStream("DEX to JAR file missing or corrupt");

                } catch (StackOverflowError | IOException e) {
                    m_progressStream.putStream(e.toString());
                }

                if (success)
                    m_progressStream.putStream("DEX to JAR complete");
                else
                    m_progressStream.putStream("DEX to JAR failed");
            }

        }, DEX2JAR_THREAD, STACK_SIZE);

        m_dex2jarThread.setPriority(Thread.MAX_PRIORITY);
        m_dex2jarThread.setUncaughtExceptionHandler(uncaughtExceptionHandler);
        m_dex2jarThread.start();

        JSONObject wrapper = new JSONObject();
        try {
            wrapper.put("dex2jar_thread", getThreadStatus( true, m_dex2jarThread));
            wrapper.put("dex2jar_url", m_appFolderUrl);

        } catch (JSONException e) {
            LogUtil.logException(LogUtil.LogType.APK_UTIL, e);
        }

        return wrapper;
    }

    public static JSONObject jar2src(Context ctx, final String package_name, String compile_method) {

        if( m_appFolderFullPath == null)
            init( ctx, package_name);

        JSONObject wrapper = new JSONObject();
        String url = "";
        String processKey = "undef";
        String processStatus = null;
        String urlKey = "";
        boolean success = false;

        MY_THREAD compileMethod = MY_THREAD.valueOf( compile_method);

        LogUtil.log(LogUtil.LogType.APK_UTIL, "compile method: "+compile_method);

        if (m_jarFile.exists() && m_jarFile.isFile()) {

            switch( compileMethod){

                case cfr: {

                    m_srcCfrFolder.mkdirs();

                    String[] args = {m_jarFile.getStdFile().toString(), "--outputdir",
                            m_srcCfrFolder.getStdFile().toString()};
                    GetOptParser getOptParser = new GetOptParser();

                    org.benf.cfr.reader.util.getopt.Options options = null;
                    try {
                        options = getOptParser.parse(args, OptionsImpl.getFactory());

                        if(!options.optionIsSet(OptionsImpl.HELP) && options.getOption(OptionsImpl.FILENAME) != null) {

                            Thread.UncaughtExceptionHandler uncaughtExceptionHandler = new Thread.UncaughtExceptionHandler() {
                                @Override
                                public void uncaughtException(Thread t, Throwable e) {

                                    LogUtil.log(LogUtil.LogType.APK_UTIL, "Uncaught exception: "+e.toString());
                                    m_progressStream.putStream("Uncaught exception: "+t.getName());
                                    m_progressStream.putStream("Uncaught exception: "+e.toString());
                                }
                            };

                            ThreadGroup group = new ThreadGroup(CFL_THREAD);
                            final org.benf.cfr.reader.util.getopt.Options finalOptions = options;
                            m_cfrThread = new Thread(group, new Runnable() {
                                @Override
                                public void run() {
                                    try {

                                        m_progressStream.putStream( "CFR starting");
                                        ClassFileSourceImpl classFileSource = new ClassFileSourceImpl(finalOptions);
                                        final DCCommonState dcCommonState = new DCCommonState(finalOptions, classFileSource);
                                        final String path = finalOptions.getOption(OptionsImpl.FILENAME);
                                        DumperFactoryImpl dumperFactory = new DumperFactoryImpl();
                                        org.benf.cfr.reader.Main.doJar( dcCommonState, path, dumperFactory);
                                        m_progressStream.putStream( "CFR doJar complete");

                                    } catch (Exception | StackOverflowError e) {
                                        m_progressStream.putStream(e.toString());
                                    }
                                    m_progressStream.putStream( "CFR complete");
                                }
                            }, CFL_THREAD, STACK_SIZE);

                            m_cfrThread.setPriority(Thread.MAX_PRIORITY);
                            m_cfrThread.setUncaughtExceptionHandler(uncaughtExceptionHandler);
                            m_cfrThread.start();

                        } else {
                            m_progressStream.putStream("exit_process_on_error");
                        }
                    } catch (Exception | StackOverflowError e) {
                        e.printStackTrace();
                    }

                    processKey = "cfr_thread";
                    processStatus = getThreadStatus( true, m_cfrThread);
                    urlKey = "cfr_url";
                    url = OmniHash.getHashedServerUrlFullPath(ctx,
                            VolUtil.sdcardVolumeId, m_srcCfrFolderPath);

                    LogUtil.log(LogUtil.LogType.APK_UTIL, compile_method+" complete");
                    break;
                }

                case jadx: {

                    Thread.UncaughtExceptionHandler uncaughtExceptionHandler = new Thread.UncaughtExceptionHandler() {
                        @Override
                        public void uncaughtException(Thread t, Throwable e) {

                            LogUtil.log(LogUtil.LogType.APK_UTIL, "Uncaught exception: "+e.toString());
                            m_progressStream.putStream("Uncaught exception: "+t.getName());
                            m_progressStream.putStream("Uncaught exception: "+e.toString());
                        }
                    };

                    ThreadGroup group = new ThreadGroup(CFL_THREAD);
                    m_jadxThread = new Thread(group, new Runnable() {
                        @Override
                        public void run() {

                            m_srcJadxFolder.mkdirs();
                            m_progressStream.putStream("JaDX starting");
                            JadxDecompiler jadx = new JadxDecompiler();
                            jadx.setOutputDir(m_srcJadxFolder.getStdFile());
                            try {
                                m_progressStream.putStream("JaDX loadFile start");
                                jadx.loadFile(m_dexFile.getStdFile());
                                m_progressStream.putStream("JaDX loadFile complete");
                            } catch (JadxException e) {
                                LogUtil.logException(LogUtil.LogType.APK_UTIL, e);
                                m_progressStream.putStream(e.toString());
                            }
                            m_progressStream.putStream("JaDX saveSources start");
                            jadx.saveSources();
                            m_progressStream.putStream("JaDX saveSources complete");
                        }
                    }, JADX_THREAD, STACK_SIZE);

                    m_jadxThread.setPriority(Thread.MAX_PRIORITY);
                    m_jadxThread.setUncaughtExceptionHandler(uncaughtExceptionHandler);
                    m_jadxThread.start();

                    processKey = "jadx_thread";
                    processStatus = getThreadStatus( true, m_jadxThread);
                    urlKey = "jadx_url";
                    url = OmniHash.getHashedServerUrlFullPath(ctx,
                            VolUtil.sdcardVolumeId, m_srcJadxFolderPath);

                    break;
                }

                case fern_flower: {// https://github.com/fesh0r/fernflower

                    m_srcFernFolder.mkdirs();

                    Thread.UncaughtExceptionHandler uncaughtExceptionHandler = new Thread.UncaughtExceptionHandler() {
                        @Override
                        public void uncaughtException(Thread t, Throwable e) {

                            LogUtil.log(LogUtil.LogType.APK_UTIL, "Uncaught exception: "+e.toString());
                            m_progressStream.putStream("Uncaught exception: "+t.getName());
                            m_progressStream.putStream("Uncaught exception: "+e.toString());
                        }
                    };

                    ThreadGroup group = new ThreadGroup(CFL_THREAD);
                    m_fernThread = new Thread(group, new Runnable() {
                        @Override
                        public void run() {

                            m_progressStream.putStream( "FernFlower starting");
                            PrintStream printStream = new PrintStream(m_progressStream);
                            System.setErr(printStream);
                            System.setOut(printStream);
                            PrintStreamLogger logger = new PrintStreamLogger(printStream);

                            final Map<String, Object> mapOptions = new HashMap<>();
                            File javaOutputDir = m_srcFernFolder.getStdFile();
                            ConsoleDecompiler decompiler = new ConsoleDecompiler(javaOutputDir, mapOptions, logger);
                            File jarInputFile = m_jarFile.getStdFile();
                            decompiler.addSpace(jarInputFile, true);

                            m_progressStream.putStream( "FernFlower decompiler.addSpace complete");
                            decompiler.decompileContext();
                            m_progressStream.putStream( "FernFlower decompiler.decompileContext complete");

                            OmniFile decompiledJarFile = new OmniFile(
                                    VolUtil.sdcardVolumeId, javaOutputDir + "/" + package_name + ".jar");
                            boolean success = unzipFile(decompiledJarFile, m_srcFernFolder, null, null);

                            if( success)
                                m_progressStream.putStream( "FernFlower decompiler.unpack complete");
                            else
                                m_progressStream.putStream( "FernFlower decompiler.unpack failed");

                            m_progressStream.putStream( "FernFlower complete");
                        }
                    }, FERN_THREAD, STACK_SIZE);

                    m_fernThread.setPriority(Thread.MAX_PRIORITY);
                    m_fernThread.setUncaughtExceptionHandler(uncaughtExceptionHandler);
                    m_fernThread.start();

                    processKey = "fern_thread";
                    processStatus = getThreadStatus( true, m_fernThread);
                    urlKey = "fern_url";
                    url = OmniHash.getHashedServerUrlFullPath(ctx,
                            VolUtil.sdcardVolumeId, m_srcFernFolderPath);

                    break;
                }
                case simple_unpack: {

                    // Simply unpack the jar file
                    success = unzipFile(m_jarFile, m_srcCfrFolder, null, null);
                    break;
                }
                default:
                    LogUtil.log(LogUtil.LogType.APK_UTIL, "unknown compile method: "+compile_method);
            }
        }


        try {
            wrapper.put("url", m_appFolderUrl);
            wrapper.put(processKey, processStatus);
            wrapper.put( urlKey, url);

        } catch (JSONException e) {
            e.printStackTrace();
        }

        return wrapper;
    }

    public static JSONObject stopThread(String myThreadName){

        MY_THREAD thread = MY_THREAD.valueOf(myThreadName);
        Thread myThread = null;

        switch(thread){

            case unpack_apk:
                myThread = m_unpackApkThread;
                break;
            case dex2jar:
                myThread = m_dex2jarThread;
                break;
            case cfr:
                myThread = m_cfrThread;
                break;
            case jadx:
                myThread = m_jadxThread;
                break;
            case fern_flower:
                myThread = m_fernThread;
                break;
            case simple_unpack:
                break;
        }

        if( myThread != null){
            if( myThread.isInterrupted())
                myThread.currentThread().stop();
            else {
                myThread.currentThread().interrupt();
            }
        }

        if( myThread != null) {
            if( myThread.isInterrupted())
                m_progressStream.putStream( "Process is interrupted: "+ myThreadName);
            else
            if( myThread.isAlive())
                m_progressStream.putStream( "Process is alive: "+ myThreadName);
            else
                m_progressStream.putStream( "Process is not alive: "+ myThreadName);
        }
        else
            m_progressStream.putStream( "Process is null: "+ myThreadName);

        JSONObject status = new JSONObject();
        try {
            status.put("stop", myThread != null && myThread.isAlive()?1:0);
        } catch (JSONException e) {
            e.printStackTrace();
        }
        return status;
    }

    private static class DexExceptionHandlerMod implements DexExceptionHandler {
        @Override
        public void handleFileException(Exception e) {
            LogUtil.logException(LogUtil.LogType.APK_UTIL, "Dex2Jar Exception", e);
        }

        @Override
        public void handleMethodTranslateException(Method method, IrMethod irMethod, MethodNode methodNode, Exception e) {
            LogUtil.logException(LogUtil.LogType.APK_UTIL, "Dex2Jar Exception", e);
        }
    }

    public static void clearStream() {

        m_progressStream.init();
    }

    public static JSONArray getStream() {

        return m_progressStream.getStream();
    }

}
