package com.nuvolect.pentest.lucene;

import android.content.Context;
import android.os.Environment;

import com.nuvolect.pentest.util.LogUtil;
import com.nuvolect.pentest.util.OmniFile;
import com.nuvolect.pentest.util.OmniHash;
import com.nuvolect.pentest.util.Util;
import com.nuvolect.pentest.webserver.connector.VolUtil;

import org.apache.commons.io.FileUtils;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;

import static com.nuvolect.pentest.webserver.MimeUtil.TEXT_FILE_EXTENSION;

public class IndexUtil {

    /**
     * Return a list of current Lucene search indexes and purge any indexes for
     * folders that no longer exist.
     * @return
     */
    public static JSONObject getCurrentIndexes(Context ctx) {

        String lucenePath = Util.getAppPublicFolderPath(ctx) + "/.lucene/";
        File luceneFolder = new File( lucenePath);
        ArrayList searchPaths = new ArrayList();

        File[] hashedDirs = luceneFolder.listFiles();
        ArrayList<File> hashedDirsToDelete = new ArrayList<>();

        for( File hashedDir : hashedDirs){

            if( hashedDir.isDirectory()){

                String hashedDirPath = hashedDir.getName();
                LogUtil.log("hashedDirPath: "+hashedDirPath);

                String volumeId = hashedDirPath.substring(0,3);
                String hash = hashedDirPath.substring(3, hashedDirPath.length());
                String path = OmniHash.decode(hash);

                LogUtil.log("volumeId: "+volumeId);
                LogUtil.log("path: "+path);

//                OmniFile omniFile = new OmniFile( volumeId, path);
                OmniFile omniFile = new OmniFile( hashedDirPath);
                LogUtil.log("omniFile.getName: "+omniFile.getName());
                LogUtil.log("omniFile.getAbsolutePath: "+omniFile.getAbsolutePath());

                if( omniFile.exists()){

                    // put on list as an active searchable path
                    searchPaths.add(path);

                }else{

                    // Folder no longer exists, save to delete below
                    hashedDirsToDelete.add( hashedDir);
                }

            }
        }

        for( File hashDirToDelete : hashedDirsToDelete)
            hashDirToDelete.delete();

        JSONObject wrapper = new JSONObject();
        try {
            wrapper.put("paths", searchPaths);
        } catch (JSONException e) {
            e.printStackTrace();
        }

        return new JSONObject();
    }

    /**
     * Get a Lucene cache folder.
     * @param relativeSearchPath
     * @return
     */
    public static File getLuceneCacheDir(Context ctx, String relativeSearchPath) {

        String volId = VolUtil.sdcardVolumeId;
        String hashedSearchPath = volId+ OmniHash.encode( relativeSearchPath);
        String lucenePath = Util.getAppPublicFolderPath(ctx) + "/.lucene/" + hashedSearchPath;
        return new File( lucenePath);
    }

    public static String getLuceneCacheDirPath(Context ctx, String relativeSearchPath) {

        String volId = VolUtil.sdcardVolumeId;
        String hashedSearchPath = volId+OmniHash.encode( relativeSearchPath);
        String lucenePath = Util.getAppPublicFolderPath(ctx) + "/.lucene/" + hashedSearchPath;
        return lucenePath;
    }

    public static boolean folderExists(String relativePath) {

        File dir = new File( Environment.getExternalStorageDirectory()+relativePath);
        return dir != null && dir.exists() && dir.isDirectory();
    }

    public static Collection getFilePaths(String topDirRelativePath) {

        File topDir = new File( Environment.getExternalStorageDirectory()+topDirRelativePath);
        Collection<File> files = FileUtils.listFiles(topDir, TEXT_FILE_EXTENSION, true);

        return files;
    }
}
