package com.nuvolect.pentest.lucene;

import android.content.Context;

import com.nuvolect.pentest.util.LogUtil;
import com.nuvolect.pentest.util.OmniHash;
import com.nuvolect.pentest.webserver.connector.VolUtil;

import org.apache.commons.io.FilenameUtils;
import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;
import org.apache.lucene.document.StoredField;
import org.apache.lucene.document.TextField;
import org.apache.lucene.index.DirectoryReader;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.index.IndexWriterConfig;
import org.apache.lucene.queryparser.classic.ParseException;
import org.apache.lucene.queryparser.classic.QueryParser;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.ScoreDoc;
import org.apache.lucene.search.TopScoreDocCollector;
import org.apache.lucene.store.Directory;
import org.apache.lucene.store.FSDirectory;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.lukhnos.portmobile.file.Paths;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;


/**
 * Methods to index and search the public file system.
 */
public class Search {

    private static Analyzer m_analyzer;
    private static Directory m_directory = null;
    public static final String FIELD_PATH = "path";
    public static final String FIELD_FILENAME = "filename";
    public static final String FIELD_CONTENT = "content";
    public static final int MAX_HITS = 20;


    /**
     * Index files recursively under the path given.  Force a re-index when specified.
     * If an index already exists, use it and setup for search.
     * @param searchPath
     * @param forceIndex
     * @return
     */
    public static JSONObject index(Context ctx, String searchPath, String forceIndex) {

        String error = "no error";
//        List stopWords = Arrays.asList(new String[]{"a", "an", "and", "are", "as", "at", "be", "but", "by", "for", "if", "in", "into", "is", "it", "no", "not", "of", "on", "or", "such", "that", "the", "their", "then", "there", "these", "they", "this", "to", "was", "will", "with"});
//        List stopWords = Arrays.asList(new String[]{});
//        CharArraySet stopSet = new CharArraySet(stopWords, false);
//        m_analyzer = new org.apache.lucene.analysis.standard.StandardAnalyzer(stopSet);
        m_analyzer = new org.apache.lucene.analysis.core.WhitespaceAnalyzer();//standard.StandardAnalyzer();

        File luceneDir = FileUtil.getLuceneCacheDir( ctx, searchPath);
        boolean cacheDirExists = ! luceneDir.mkdirs();
        boolean indexRequired = ! cacheDirExists || forceIndex.contentEquals("1");
        int m_indexedDocs = 0;

        try {
            m_directory = FSDirectory.open( Paths.get( luceneDir.getCanonicalPath()));
        } catch (IOException e) {
            LogUtil.logException(LogUtil.LogType.LUCENE, e);
        }

        if( indexRequired){

            IndexWriterConfig config = new IndexWriterConfig(m_analyzer);
            IndexWriter iwriter = null;

            try {
                iwriter = new IndexWriter(m_directory, config);
                iwriter.deleteAll();
                iwriter.commit();
            } catch (IOException e) {
                LogUtil.logException(LogUtil.LogType.LUCENE, e);
                error = "IndexWriter constructor exception";
            }

            Collection files = FileUtil.getFilePaths( searchPath);
            m_indexedDocs = files.size();

            try {

                for( Object filePath : files){

                    LogUtil.log(LogUtil.LogType.SEARCH, "indexing: "+filePath.toString());
                    iwriter.addDocument(makeDoc( filePath.toString() ));
                }

                iwriter.commit();
                iwriter.close();

            } catch (IOException e) {
                LogUtil.logException(LogUtil.LogType.LUCENE, e);
                error = "IndexWriter addDocument exception";
            }
        }else{

            // Indexing not required
            // Get number of documents indexed
            try {
                DirectoryReader ireader = DirectoryReader.open(m_directory);
                m_indexedDocs = ireader.numDocs();
                ireader.close();
            } catch (IOException e) {
                LogUtil.logException(LogUtil.LogType.LUCENE, e);
            }
        }

        JSONObject result =new JSONObject();
        try {
            result.put("error", error);
            result.put("indexed_docs", m_indexedDocs);
            result.put("full_path", luceneDir.getAbsolutePath());
            result.put("search_path", searchPath);
        } catch (JSONException e) {
            e.printStackTrace();
        }

        return result;
    }

    /**
     * Build a single document to be indexed with additional data to be returned with search results.
     * @param filePath
     * @return
     * @throws IllegalArgumentException
     * @throws FileNotFoundException
     */
    private static Document makeDoc(String filePath) throws IllegalArgumentException, FileNotFoundException {

        Document doc = new Document();

        String fileName = FilenameUtils.getName( filePath);
        // Tokenize, index and store
        doc.add(new TextField(FIELD_FILENAME, fileName, Field.Store.YES));

        // Only stored, not indexed
        doc.add( new StoredField(FIELD_PATH, filePath));

        // Index only, do not store
        File file = new File( filePath);
        java.io.Reader reader = new java.io.FileReader( file );
        doc.add(new Field( FIELD_CONTENT, reader, TextField.TYPE_NOT_STORED));

        return doc;
    }

    /**
     * Return results for a search along a specific path.  If the path is changed or new
     * create an index.
     * @param search_query
     * @param search_path
     * @return
     */
    public static JSONObject search(Context ctx, String search_query, String search_path) {

        JSONObject result = new JSONObject();
        JSONArray jsonArray = new JSONArray();

        DirectoryReader ireader = null;
        ScoreDoc[] scoreDocs = null;
        String error = "";

        index( ctx, search_path, "0");// 0 == don't force reindex
        try {
            ireader = DirectoryReader.open(m_directory);
        } catch (IOException e) {
            LogUtil.logException(LogUtil.LogType.LUCENE, e);
            error += e.toString();
        }
        IndexSearcher isearcher = new IndexSearcher(ireader);

        try {

// Use BooleanClause.Occur.MUST instead of BooleanClause.Occur.SHOULD
// for AND queries
//            BooleanQuery.Builder builder = new BooleanQuery.Builder();
//            Query fileNameQuery = new TermQuery(new Term( FIELD_FILENAME, search_query));
//            Query fileContentQuery = new TermQuery(new Term( FIELD_CONTENT, search_query));
//            builder.add( fileNameQuery, BooleanClause.Occur.SHOULD);
//            builder.add( fileContentQuery, BooleanClause.Occur.SHOULD);
//            Query finalQuery = builder.build();
//            scoreDocs = isearcher.search( finalQuery, MAX_HITS).scoreDocs;

            // Parse a simple query that searches for "text":
            QueryParser parser = new QueryParser( FIELD_CONTENT, m_analyzer);
            Query query = null;
            query = parser.parse( search_query);
            TopScoreDocCollector collector = TopScoreDocCollector.create( MAX_HITS);
            isearcher.search( query, collector);
            scoreDocs = collector.topDocs().scoreDocs;

//            scoreDocs = isearcher.search(query, MAX_HITS).scoreDocs;
//
//            if( scoreDocs.length == 0){
//
//                parser = new QueryParser( FIELD_FILENAME, m_analyzer);
//                query = parser.parse( search_query);
//                scoreDocs = isearcher.search(query, MAX_HITS).scoreDocs;
//            }

        } catch ( ParseException | IOException e) {
            LogUtil.logException(LogUtil.LogType.LUCENE, e);
            error += e.toString();
        }
        // Iterate through the results creating an object for each file
        HashMap<String, Integer> hitCounts = new HashMap<>();
        HashMap<String, Integer> hitIndexes = new HashMap<>();

        /**
         * First iterate the hit list and count duplicates based on file path.
         */
        for (int ii = 0; scoreDocs != null && ii < scoreDocs.length; ++ii) {

            Document hitDoc = null;
            try {
                hitDoc = isearcher.doc(scoreDocs[ii].doc);
            } catch (IOException e) {
                LogUtil.logException(LogUtil.LogType.LUCENE, e);
                error += e.toString();
            }
            String filePath = hitDoc.get(( FIELD_PATH));

            if( hitCounts.containsKey(filePath))
                hitCounts.put( filePath, hitCounts.get( filePath) + 1);
            else{
                hitCounts.put( filePath, 1);
                hitIndexes.put( filePath, ii);
            }
        }

        /**
         * Iterate over each unique hit and save the results
         */
        for(Map.Entry<String, Integer> uniqueHit : hitIndexes.entrySet()){

            Document hitDoc = null;
            try {
                hitDoc = isearcher.doc(scoreDocs[ uniqueHit.getValue() ].doc);
            } catch (IOException e) {
                LogUtil.logException(LogUtil.LogType.LUCENE, e);
                error += e.toString();
            }
            String file_name = hitDoc.get(( FIELD_FILENAME));
            String file_path = hitDoc.get(( FIELD_PATH));
            File parentFolder = new File( file_path).getParentFile();
            try {
                String folder_path = parentFolder.getCanonicalPath();
                String folder_url = OmniHash.getHashedServerUrlFullPath( ctx, VolUtil.sdcardVolumeId, folder_path);

                JSONObject hitObj = new JSONObject();
                hitObj.put("file_name", file_name);
                hitObj.put("file_path", file_path);
                hitObj.put("folder_url", folder_url);
                hitObj.put("num_hits", hitCounts.get(file_path));
                hitObj.put("error", error);
                jsonArray.put(hitObj);

            } catch (JSONException | IOException e) {
                LogUtil.logException(LogUtil.LogType.LUCENE, e);
            }
        }

        try {
            result.put("hits", jsonArray!=null?jsonArray:new JSONArray());
            result.put("num_hits", scoreDocs!=null?scoreDocs.length:0);
            result.put("error", error);

            ireader.close();
            m_directory.close();

        } catch (JSONException | IOException e) {
            LogUtil.logException(LogUtil.LogType.LUCENE, e);
        }

        return result;
    }
}
